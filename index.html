
<!-- 
    Hover on entrypoints to see elements.
    Left click on entrypoints to toggle selected state.
    Right on elements to copy link, if no link then the text will be copied instead.
    Pic Highlighter V1.0.0
 -->

<canvas id="canvas" width="920" height="512" ></canvas>

<script>
    const requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || // this redraws the canvas when the browser is updating. Crome 18 is execllent for canvas, makes it much faster by using os
						   window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame
						   || function(callback) { window.setTimeout(callback,1000/60);}; //moz firefox 4 up, o Opera, ms IE 9, not standardised yet so need different browsers

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = 'green';
    ctx.fillRect(10, 10, 150, 100);

    let data = null;
    let entryPoints = [];
    let bgImage = null;

    const lib2d = {
        loadImage({src}) {
            let imga = new Image();
            if(src.indexOf("data:image") > -1){
                imga.src = src;
            }
            return imga;
        },
        reversed(array){
            let arr = [];
            for(let i = (array.length-1); i > -1;i--){
                arr.push(array[i])
            }
            return arr;
        },
        pointInsideSprite(point, sprite) {
            if(point.x > sprite.x && point.x < (sprite.x+sprite.sizeX) ){
                if(point.y > sprite.y && point.y < (sprite.y+sprite.sizeY)){
                    return true;
                }
            }
        }
    }

    // Drawing
    const drawing = {
        drawBorder(x,y,sizeX,sizeY, width,color, fill, style, ctx) {
            ctx.save();     
            ctx.beginPath()
            if(style === "DOTTED") {
            ctx.setLineDash([5, 5]);
            }
            if (fill) {
            ctx.fillStyle = fill
            ctx.fillRect(x,y,sizeX,sizeY);
            }
            ctx.lineWidth = width;
            ctx.strokeStyle = color;
            ctx.strokeRect(x,y,sizeX,sizeY);
            
            ctx.closePath()
            ctx.restore();
        },
        drawLine(x,y,xx,yy, width, color, style, ctx) {
            ctx.save();    
            ctx.beginPath();
            if(style === "DOTTED") {
            ctx.setLineDash([5, 5]);
            }
            ctx.lineWidth = width;
            ctx.moveTo(x, y);
            ctx.lineTo(xx, yy);
            ctx.strokeStyle = color;
            ctx.stroke();
            ctx.closePath();
            ctx.restore();
        },
        drawArrowHeads(x,y,xx,yy, width,color,ctx, start, end, startStyle,endStyle,startSize,endSize) {
            // draw the starting arrowhead
            if(start){
                var startRadians=Math.atan((yy-y)/(xx-x));
                startRadians+=((xx>x || xx === x)?-90:90)*Math.PI/180;
                this.drawArrowHead(x,y,startRadians,width,color,ctx,startStyle,startSize);
            }
            // draw the ending arrowhead
            if(end){
                var endRadians=Math.atan((yy-y)/(xx-x));
                endRadians+=((xx>x || xx === x)?90:-90)*Math.PI/180;
                this.drawArrowHead(xx,yy,endRadians,width,color,ctx,endStyle,endSize);
            }
        },
        drawArrowHead (x,y,radians, width,color,ctx, style, size) {
            ctx.save();
            ctx.beginPath();
            ctx.lineWidth = width;
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.translate(x,y);
            ctx.rotate(radians);
            ctx.moveTo(0,0);
            let sizes = this.getSize(size);
            if(style === "ARROW"){
                ctx.lineTo(sizes.nose,sizes.wing);
                ctx.lineTo(0,0);
                ctx.lineTo(sizes.nose*-1,sizes.wing);
            } else { // Full or Empty so draw the entire arrow
                ctx.lineTo(sizes.nose,sizes.wing);
                ctx.lineTo(sizes.nose*-1,sizes.wing);
            }
            ctx.closePath();
            ctx.stroke();
            if(style === "FILLED"){ ctx.fill(); }
            if(style === "UNFILLED"){ ctx.fillStyle = "#FFF";ctx.fill(); }
            ctx.restore();
        },
        getSize(size) {
            if(size === "TINY"){
                return {nose:5,wing:6}
            } else   if(size === "SMALL"){
                return {nose:5,wing:9}
            } else   if(size === "MEDIUM"){
                return {nose:6,wing:12 }
            } else   if(size === "LARGE"){
                return {nose:10,wing:20}
            } else   if(size === "HUGE"){
                return {nose:15,wing:30}
            }
            return {nose:5,wing:10};
        },
        drawCircle(x, y, radius, fill, stroke, strokeWidth, style, ctx) {
            ctx.save();  
            ctx.beginPath()
            if(style === "DOTTED") {
            ctx.setLineDash([5, 5]);
            }
            ctx.arc(x, y, radius, 0, 2 * Math.PI, false)
            if (fill) {
            ctx.fillStyle = fill
            ctx.fill()
            }
            if (stroke) {
            ctx.lineWidth = strokeWidth
            ctx.strokeStyle = stroke
            ctx.stroke()
            }
            ctx.closePath()
            ctx.restore();
        },
        drawShape(cords, width, color, fill, style, ctx) {
            ctx.save();  
            ctx.beginPath();
            ctx.lineWidth = width;
            if(style === "DOTTED") {
                ctx.setLineDash([5, 5]);
            }
            let cord1=cords[0];
            ctx.moveTo(cord1.x, cord1.y);
            for(let i =1; i < cords.length;i++){
                cord1 = cords[i];
                ctx.lineTo(cord1.x, cord1.y);
            }
            ctx.closePath()
            if(fill){
                ctx.fillStyle = fill;
                ctx.fill();
            }
            ctx.strokeStyle = color;
            ctx.stroke();
            ctx.restore();
        },
        drawRoundRect (x, y, sizeX,sizeY, width, radius, color, fill, style, ctx) {
            ctx.save();  
            ctx.beginPath();
            if (typeof radius === 'undefined') {
                radius = 5;
            }
            if (typeof radius === 'number') {
                radius = {tl: radius, tr: radius, br: radius, bl: radius};
            } else {
                var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0};
                for (var side in defaultRadius) {
                    radius[side] = radius[side] || defaultRadius[side];
                }
            }
            if( style === "DOTTED" ) {
                ctx.setLineDash([5, 5]);
            }
            ctx.lineWidth = width;
            ctx.moveTo(x + radius.tl, y);
            ctx.lineTo(x + sizeX - radius.tr, y);
            ctx.quadraticCurveTo(x + sizeX, y, x + sizeX, y + radius.tr);
            ctx.lineTo(x + sizeX, y + sizeY - radius.br);
            ctx.quadraticCurveTo(x + sizeX, y + sizeY, x + sizeX - radius.br, y + sizeY);
            ctx.lineTo(x + radius.bl, y + sizeY);
            ctx.quadraticCurveTo(x, y + sizeY, x, y + sizeY - radius.bl);
            ctx.lineTo(x, y + radius.tl);
            ctx.quadraticCurveTo(x, y, x + radius.tl, y);
            ctx.closePath();
            if (fill) {
                ctx.fillStyle = fill;
                ctx.fill();
            }
            ctx.strokeStyle = color;
            ctx.stroke();
            ctx.restore();
        },
        drawOval (x, y, sizeX,sizeY, width, color, fill, style, ctx) {
            ctx.save();  
            ctx.beginPath();
            if( style === "DOTTED" ) {
                ctx.setLineDash([5, 5]);
            }
            ctx.lineWidth = width;
            ctx.ellipse(x, y, sizeX, sizeY, 0, 0, Math.PI*2);
            if (fill) {
                ctx.fillStyle = fill;
                ctx.fill();
            }
            ctx.strokeStyle = color;
            ctx.stroke();
            ctx.restore();
        },
        drawDatabase(x, y, sizeX,sizeY, width, color, fill, style, ctx) {
            ctx.save();  
            ctx.beginPath();
            if( style === "DOTTED" ) {
                ctx.setLineDash([5, 5]);
            }
            ctx.lineWidth = width;
            ctx.strokeStyle = color;
            ctx.fillStyle = fill;

            ctx.ellipse(x, y+(sizeY/2), sizeX, sizeY/2, 0, 0, Math.PI*2);
            if (fill) {ctx.fill();}
            ctx.stroke();
            // this rect is drawn over the first ellipse to add the sides
            ctx.beginPath();
            ctx.strokeRect(x-sizeX,y-(sizeY/2),sizeX*2,sizeY);
            // finally the top ellipse
            ctx.beginPath();
            ctx.ellipse(x, y-(sizeY/2), sizeX, sizeY/2, 0, 0, Math.PI*2);
            if (fill) {
                ctx.fill();
                ctx.fillRect(x-sizeX,y-(sizeY/2),sizeX*2,sizeY);
            }
            ctx.stroke();
            ctx.restore();
        },
        drawPackage (x, y, sizeX,sizeY, width, color, fill, style, ctx) {
            ctx.save();  
            ctx.beginPath();
            if( style === "DOTTED" ) {
                ctx.setLineDash([5, 5]);
            }
            ctx.lineWidth = width;
            ctx.strokeStyle = color;
            ctx.fillStyle = fill;
            let sizeYTop = (sizeY/4)
            ctx.strokeRect(x,y, (sizeX/4), sizeYTop);
            if (fill) {
                ctx.fill();
                ctx.fillRect(x,y, (sizeX/4), sizeYTop);
            }
            ctx.beginPath();
            ctx.strokeRect(x,y+sizeYTop, sizeX, sizeY-sizeYTop);
            ctx.stroke();
            ctx.restore();
        },
        drawClass (x, y, sizeX,sizeY, width, color, fill, style, ctx) {
            ctx.save();  
            ctx.beginPath();
            if( style === "DOTTED" ) {
                ctx.setLineDash([5, 5]);
            }
            ctx.lineWidth = width;
            ctx.strokeStyle = color;
            ctx.fillStyle = fill;
            let sizeYTop = (sizeY/3)
            ctx.strokeRect(x,y, sizeX, sizeYTop);
            if (fill) {ctx.fillRect(x,y, sizeX, sizeYTop);}
            ctx.beginPath();
            ctx.strokeRect(x,y+sizeYTop, sizeX, sizeY-sizeYTop);
            if (fill) {ctx.fillRect(x,y+sizeYTop, sizeX, sizeY-sizeYTop);}
            ctx.restore();
        },
        writeInPixels(x, y, size, text, color, align, cords, sizes, ctx){
            //ctx.font = size + "px 'Century Gothic'";
            if(align === "SIDEBARLEFT"){
                let newX = cords.x + (y-cords.y);
                let newY = cords.y + sizes.sizeY
                ctx.save();
                ctx.font = size + "px 'sans-serif'";
                ctx.fillStyle = color;
                ctx.translate( newX, newY);
                ctx.rotate(-Math.PI/2);
                ctx.fillText(text, 5, 0);
                ctx.restore();
            } else if(align === "SIDEBARCENTER"){
                let newX = cords.x + (y-cords.y);
                let newY = cords.y + (sizes.sizeY/2)
                ctx.save();
                ctx.font = size + "px 'sans-serif'";
                ctx.fillStyle = color;
                ctx.translate( newX, newY);
                ctx.rotate(-Math.PI/2);
                ctx.textAlign = 'center';
                ctx.fillText(text, 5, 0);
                ctx.restore();
            } else if (align === "CENTER" || align === "TOPCENTER") {
                ctx.save();
                ctx.font = size + "px 'sans-serif'";
                ctx.fillStyle = color;
                let textSpace = ctx.measureText(text).width;
                ctx.fillText(text, cords.x+ ((sizes.sizeX-textSpace)/2), y);
                ctx.restore();
            } else {
                ctx.save();
                ctx.font = size + "px 'sans-serif'";
                ctx.fillStyle = color;
                ctx.fillText(text, x, y);
                ctx.restore();
            }
        },
        /**
         * Calc how many chunks there will be
         * Then calculate the postions of them, factoring in alignment
         * OOS shape support.
         * returns chunks:[{x,y,text}]
         */
        calculateChunks (x, y, sizeX, sizeY, textSize, text, align, shape) {
            if(sizeX > 5 && sizeY > 2) {
                if(align === "CODE"){
                    let texts = text.split("\n");
                    let chunks = [];
                    let topPadding = Math.round((textSize/100) * 130);
                    for(let i = 0; i < texts.length;i++) {
                        chunks.push({x:x + 5,y:y+topPadding+(i*textSize),text:texts[i] });
                    }
                    return chunks
                }
                text = text.trim();
                const len = text.length;
                let maxLen = Math.floor(sizeX / (textSize/2)) + Math.floor(sizeX/100);
                if(align === "SIDEBARLEFT" || align === "SIDEBARCENTER") { // the size is actually measured by height when doing sidebar
                maxLen = Math.floor(sizeY / (textSize/2)) + Math.floor(sizeY/100);
                }
                let curLen = 0;
                let texts = [];
                // work out the chunks of text based on the space
                for(let i =0; curLen < len; i++) {
                let max = (curLen+maxLen >= len)?len:curLen+maxLen;
                while(text.charAt(max)!== ' ' && max < len && max > 2){max--;}
                let txt = text.substring(curLen,max); //.trim();

                // Check for newlines in this text and split on it.
                let newLineSplits = txt.split('\n');// .map(t => t.trim());
                if(newLineSplits.length === 1){
                    curLen = max;
                } else {
                    curLen = curLen + newLineSplits[0].length + 1 // +1 to get past the \n
                }
                texts.push(newLineSplits[0]);
                if(i > 10000) return []; // sanity fallback
                }
                texts = texts.map(t => t.trim()).filter(t => t.length > 0); // trim everything. We cannot do it above, because we need the full lenghts for measuring
                // then do the alignment
                let chunks = [];
                // for standard style
                if(align === "TOPLEFT" || align === "SIDEBARLEFT" || align === "SIDEBARCENTER") {
                let topPadding = Math.round((textSize/100) * 90);
                for(let i = 0; i < texts.length;i++) {
                    chunks.push({x:x + 5,y:y+topPadding+(i*textSize),text:texts[i] });
                }
                } else if(align === "CENTER") {
                // TODO
                let halfText = textSize/2;
                let startingY = 5 + (sizeY/2);
                let startingX = (sizeX/2);
                // Lets work out the starting Y
                if(texts.length % 2 === 0 && texts.length > 1){ // even
                    let even = texts.length/2;
                    startingY = (startingY+halfText) - (textSize * even);
                } else if((texts.length % 2 === 1 && texts.length > 1)){
                    let odd = Math.floor(texts.length/2); // round down.
                    startingY = startingY - (textSize * odd);
                }
                // X will be worked out independently for each line
                for(let i = 0; i < texts.length;i++) {
                    let txt = texts[i];
                    let centeringAdjustment = 0;
                    if(txt.length < 10) centeringAdjustment = halfText;
                    let percentage = ((txt.length/maxLen)*100); // whats this text % of the total length is this string? Then half it.
                    let widthOffset = ((sizeX/2)/100)*percentage; // now take this half percentage from the startingX which is centered.
                    chunks.push({x:x+(startingX - widthOffset)-centeringAdjustment ,y:y+startingY+(i*textSize),text:texts[i] });
                }
                } else if(align === "TOPCENTER") {
                // TODO
                let halfText = textSize/2;
                let startingY = Math.round((textSize/100) * 90);
                let startingX = (sizeX/2);
                // X will be worked out independently for each line
                for(let i = 0; i < texts.length;i++) {
                    let txt = texts[i];
                    let centeringAdjustment = 0;
                    if(txt.length < 10) centeringAdjustment = halfText;
                    let percentage = ((txt.length/maxLen)*100); // whats this text % of the total length is this string? Then half it.
                    let widthOffset = ((sizeX/2)/100)*percentage; // now take this half percentage from the startingX which is centered.
                    chunks.push({x:x+(startingX - widthOffset)-centeringAdjustment ,y:y+startingY+(i*textSize),text:texts[i] });
                }
                }

                return chunks;
            } else {
                return [];
            }
        }
    }

    /*****************************************************************************************************************************/
    /*******************************************         Mouse  ******************************************************************/
    /*****************************************************************************************************************************/

    const mouseFunctions = {
        mouseX:0,
        mouseY:0,
        updateMousePosition(e){
            const v= this.getOffset(canvas);
            mouseX =  Math.floor(e.pageX)-v.left;
            mouseY =  Math.floor(e.pageY)-v.top;
            lib2d.reversed(getCurrentEntryPoints()).forEach(e => {
                e.setHovered(lib2d.pointInsideSprite({x:mouseX,y:mouseY},e.hitboxes()));
            })
	    },

        mouseClick(e){
            const v= this.getOffset(canvas);
            mouseX =  Math.floor(e.pageX)-v.left;
            mouseY =  Math.floor(e.pageY)-v.top;
            if(e.button == 0){ // 0 = left click
                let rev = lib2d.reversed(getCurrentEntryPoints());
                for(let i = 0; i < rev.length; i++){
                    if(lib2d.pointInsideSprite({x:mouseX,y:mouseY},rev[i].hitboxes())){
                        rev[i].toggleSelected(); 
                        break;
                    }
                }
            }
        },

        mouseClickRelease(e){},

        // this is just a catch for the context menu, to prevent it from appearing.
        rightClickContext(e){ 
            e.preventDefault();
            const v= this.getOffset(canvas);
            mouseX =  Math.floor(e.pageX)-v.left;
            mouseY =  Math.floor(e.pageY)-v.top;
            let rev = lib2d.reversed(getCurrentEntryPoints());
            for(let i = 0; i < rev.length; i++){
                let ep = rev[i];
                if(lib2d.pointInsideSprite({x:mouseX,y:mouseY},ep.hitboxes())){
                    ep.copylink();
                    return;
                }
                if(ep._isSelected) { // if its not selected then we should not be able to see its elements for right clicking, right?
                    let revElements = lib2d.reversed(ep.elements);
                    for(let i = 0; i < revElements.length; i++){
                        if(lib2d.pointInsideSprite({x:mouseX,y:mouseY},revElements[i].hitboxes())){
                            revElements[i].copylink();
                            return;
                        }
                    }
                }
            }
        },

        doubleClick(e){},
        getOffset(el) {
            const rect = el.getBoundingClientRect();
            return {
                left: rect.left + window.scrollX,
                top: rect.top + window.scrollY
            }
        }

    }
    document.getElementById('canvas').addEventListener("mousemove", mouseFunctions.updateMousePosition.bind(mouseFunctions), false);
    document.getElementById('canvas').addEventListener("dblclick", mouseFunctions.doubleClick.bind(mouseFunctions), false);
    document.getElementById('canvas').addEventListener("mousedown", mouseFunctions.mouseClick.bind(mouseFunctions), false);
    document.getElementById('canvas').addEventListener("mouseup", mouseFunctions.mouseClickRelease.bind(mouseFunctions), false);
    document.getElementById('canvas').addEventListener("contextmenu", mouseFunctions.rightClickContext.bind(mouseFunctions), false);


    /*****************************************************************************************************************************/
    /*******************************************   entrypoints  ******************************************************************/
    /*****************************************************************************************************************************/
    
    class DiagramElement {
        id= "replacement";
        name = 'replacement'; 
        color = '#bbb';
        strokeWidth=.4;
        lineStyle = "FULL";
        cords = {x:0,y:0};

        constructor(options) {
            Object.assign(this, options);
        }

        hitboxes(){return {x:0,y:0,sizeX:0,sizeY:0}}
    }

    class Shape extends DiagramElement {
        size = {sizeX:0,sizeY:0};
        shape = "RECT";
        link="";
        text="";
        textSize = 15;
        textColor = '#333'
        textAlign = "CENTER";
        fillColor = "#FFFFFF";
        isFilled =false;
        _chunks = [];

        constructor(options) {
            super();
            Object.assign(this, options);
        }

        getFill() {
            return (this.isFilled)?this.fillColor:null;
        }

        getColor() {
            return this.color;
        }
        // Copy the link if there is one, else copy the text.
        copylink(){
            if(this.link && this.link !== ""){
                var input = document.createElement('input');
                input.setAttribute('value', this.link);
                document.body.appendChild(input);
                input.select();
                var result = document.execCommand('copy');
                document.body.removeChild(input);
                return result;
            } else if(this.text && this.text !== ""){
                var input = document.createElement('input');
                input.setAttribute('value', this.text);
                document.body.appendChild(input);
                input.select();
                var result = document.execCommand('copy');
                document.body.removeChild(input);
                return result;
            }
        }

        draw(ctx) {
            if(this.shape === "RECT") {
                drawing.drawBorder( this.cords.x,this.cords.y,this.size.sizeX,this.size.sizeY,this.strokeWidth,this.color,this.getFill(),this.lineStyle,ctx )
            } else if(this.shape === "ROUNDEDRECT") {
                drawing.drawRoundRect( this.cords.x, this.cords.y, this.size.sizeX, this.size.sizeY, this.strokeWidth, 5, this.getColor(), this.getFill(), this.lineStyle, ctx )
            }  else if(this.shape === "PACKAGE") {
                drawing.drawPackage( this.cords.x, this.cords.y, this.size.sizeX, this.size.sizeY, this.strokeWidth, this.getColor(), this.getFill(), this.lineStyle, ctx )
            } else if(this.shape === "CLASS") {
                drawing.drawClass( this.cords.x, this.cords.y, this.size.sizeX, this.size.sizeY, this.strokeWidth, this.getColor(), this.getFill(), this.lineStyle, ctx )
            } else if(this.shape === "OVAL") {
                drawing.drawOval( this.cords.x + this.size.sizeX/2 , this.cords.y + this.size.sizeY/2, this.size.sizeX/2, this.size.sizeY/2, this.strokeWidth, this.getColor(), this.getFill(), this.lineStyle, ctx )
            } else if(this.shape === "DATABASE") {
                drawing.drawDatabase( this.cords.x + this.size.sizeX/2 , this.cords.y + this.size.sizeY/2, this.size.sizeX/2, this.size.sizeY/2, this.strokeWidth, this.getColor(), this.getFill(), this.lineStyle, ctx )
            } else if(this.shape === "DIAMOND") {
                const left = {x:this.cords.x, y :this.cords.y+ (this.size.sizeY/2) };
                const top = {x:this.cords.x + (this.size.sizeX/2), y :this.cords.y };
                const right = {x:this.cords.x + this.size.sizeX, y :this.cords.y+ (this.size.sizeY/2) };
                const bottom = {x:this.cords.x+ (this.size.sizeX/2), y :this.cords.y+ this.size.sizeY };

                drawing.drawShape([{x:left.x,y:left.y},{x:top.x,y:top.y},{x:right.x,y:right.y},{x:bottom.x,y:bottom.y},{x:left.x,y:left.y}], this.strokeWidth, this.color, this.getFill(), this.lineStyle, ctx)
                // TODO replace with a drawshape method, takes cords, connects the dots with lines, fills with provided fill value
            } else if(this.shape === "CIRCLE") {
                drawing.drawCircle( this.cords.x + (this.size.sizeX/2),this.cords.y + (this.size.sizeY/2),this.size.sizeX/2,this.getFill(),this.color,this.strokeWidth,this.lineStyle,ctx )
            }
            this._chunks.forEach(_chunks => {
                // writeInPixels(this.cords.x+this.size.sizeX/2, this.cords.y+this.size.sizeY/2,15,this.text,this.color,ctx);
                drawing.writeInPixels(_chunks.x, _chunks.y, this.textSize, _chunks.text,this.textColor,this.textAlign, this.cords, this.size, ctx);
            })
        }

        drawHover(ctx){
            drawing.drawBorder(this.cords.x,this.cords.y,this.size.sizeX,this.size.sizeY,this.strokeWidth, this.getColor(), null, this.lineStyle, ctx)
        }

        hitboxes(){return {...this.cords,...this.size}}
        
    }

    class EntryPoint extends Shape {
        // All of the elements related to this entrypoint
        elements=[]
        isHoverable =true; // if not hoverable, it will not highlight the box when hovered over, and not display the elements(TODO extract second part to new Variable?).
        hoverBorderColor = "#000";
        isSelectable =true;
        isSelectedByDefault = false; // when this is true, it will be selected on first draw. Could be used as a BG in absence of an image.
        selectedFillColor = "#FFFFFF"; // when this is true, and not selected, a light colored outline with display where is.
        selectedBorderColor = "#FFFFFF"; // when this is true, and not selected, a light colored outline with display where is.
        
        _isHovered=false;
        _isSelected=false;
        _hoverOverride=false;// when I deselect I want to override the hover.

        constructor(options) {
            super();
            Object.assign(this, options);
            let elementsCon = [];
            for(let el of this.elements) {
                if(el.id.startsWith("LN")) {
                    elementsCon.push(new Line(el));
                } else if(el.id.startsWith("SH")){
                    elementsCon.push(new Shape(el));
                } else if(el.id.startsWith("SEP")){
                    elementsCon.push(new EntryPoint(el));
                }
            }
            this.elements = elementsCon;
            this._isSelected = this.isSelectedByDefault;
        }

        setHovered(bool){this._isHovered= bool; if(!this._isHovered){this._hoverOverride = false}}
        toggleSelected(){
            this._isSelected = !this._isSelected; 
            this._hoverOverride = true;
            if(this._isSelected === false){
                let sep = this.getSEP();
                sep.forEach(ep => {
                    ep.toggleSelected(false)
                })
            }
        }
        
        shouldDraw(){
            return true;
        }

        shouldDisplayElements(){
            return (this._isHovered && !this._hoverOverride) || this._isSelected;
        }

        // TEXT OOS
        draw(ctx) {
            if(this.shouldDisplayElements()){
                this.elements.forEach( (el) => {
                    el.draw(ctx)
                });
            }
            super.draw(ctx);
            if(this._isHovered && !this._hoverOverride){
                this.drawHover(ctx);
            }
        }
        
        getFill() {
            if(this.isFilled){
                if(this._isSelected){
                    return this.selectedFillColor;
                } else {
                    return this.fillColor;
                }
            }
            return null;
        }

        getColor() {
            if(this._isHovered) {
                return this.hoverBorderColor;
            } else if(this._isSelected){
                return this.selectedBorderColor;
            } else {
                return this.color;
            }
        }

        // Find all of the sub entry points and return then.
        getEP(){
            let arr = [this];
            if(this._isSelected) {
                arr = arr.concat(this.getSEP())
            }
            return arr;
        }
        getSEP(){
            let arr = [];
            this.elements.forEach(element => {
                if(element instanceof EntryPoint){
                    arr = arr.concat(element.getEP())
                }
            });
            return arr;
        }
    }

    class Line extends DiagramElement {
        startArrowStyle = "NONE";
        endArrowStyle = "NONE";    
        startArrowSize = "SMALL";
        endArrowSize = "SMALL";
        secondaryCords = [];

        constructor(options) {
            super();
            Object.assign(this, options);
        }
    
        draw(ctx){
            let drawer = drawing.drawLine;
            if(!this.cordsSet && this.tempStartCord && this.tempCord){
                drawer( this.tempStartCord.x, this.tempStartCord.y, this.tempCord.x, this.tempCord.y, this.strokeWidth, this.color, this.lineStyle, ctx)
            } else {
                let first = this.cords;
                for(let i = 0; i < this.secondaryCords.length; i++){
                    let sec = this.secondaryCords[i];
                    drawer(
                        first.x,first.y,sec.x,sec.y,this.strokeWidth,this.color,this.lineStyle,ctx
                    )
                    first = sec;
                }
                // draw the arrow heads for the two ends
                if(this.secondaryCords.length > 1) {
                    if(this.startArrowStyle !== "NONE"){
                        drawing.drawArrowHeads(this.cords.x,this.cords.y,this.secondaryCords[0].x,this.secondaryCords[0].y,this.strokeWidth,this.color,ctx,
                            true,false, this.startArrowStyle, this.endArrowStyle,this.startArrowSize,this.endArrowSize);
                    }
                    if(this.endArrowStyle !== "NONE") {
                        let secondLast = this.secondaryCords[this.secondaryCords.length-2];
                        let last = this.secondaryCords[this.secondaryCords.length-1];
                        drawing.drawArrowHeads(secondLast.x,secondLast.y,last.x,last.y,this.strokeWidth,this.color,ctx,
                            false,true, this.startArrowStyle, this.endArrowStyle,this.startArrowSize,this.endArrowSize);
                    }
                } else {
                    drawing.drawArrowHeads(this.cords.x,this.cords.y,first.x,first.y,this.strokeWidth,this.color,ctx,
                        (this.startArrowStyle !== "NONE"), (this.endArrowStyle !== "NONE"), 
                        this.startArrowStyle, this.endArrowStyle,this.startArrowSize,this.endArrowSize);
                }
                
                if(this.held && this.tempCord){
                    drawer(
                        first.x, first.y, this.tempCord.x, this.tempCord.y, this.strokeWidth, this.color, this.lineStyle, ctx
                    )
                }
            }
        }
    }

    class HitBox {
        constructor(hitBoxX, hitBoxY, hitBoxSizeX, hitBoxSizeY ){}
        areCentersToClose(first, a,second, b) {
            let ax = first.posX+a.hitBoxX;
            let ay = first.posY+a.hitBoxY;
            let bx = second.posX+b.hitBoxX;
            let by = second.posY+b.hitBoxY;
            return  (this.absVal( (ax+(a.hitBoxSizeX >> 1))  - (bx + (b.hitBoxSizeX >> 1)) ) < ((a.hitBoxSizeX >>1) + (b.hitBoxSizeX >> 1))) &&
                    (this.absVal( (ay+(a.hitBoxSizeY >> 1))  - (by + (b.hitBoxSizeY >> 1)) ) < ((a.hitBoxSizeY >> 1) + (b.hitBoxSizeY >> 1)));
        }
        absVal(val) { return (val < 0) ? -val : val; }
    }
    
    function getCurrentEntryPoints(){
        let array = [];
        entryPoints.forEach(ep => {
            array = array.concat(ep.getEP())
        });
        return array;
    }

    // Main logic block for rendering.
    function render() {
        if(data) {
            ctx.canvas.width  = data._defaultValues.width;
            ctx.canvas.height = data._defaultValues.height;
            ctx.clearRect(0,0, data._defaultValues.width, data._defaultValues.height); // clear the rect
            ctx.fillStyle = data._defaultValues.backgroundColor;
            ctx.fillRect(0,0,data._defaultValues.width, data._defaultValues.height);
            if(bgImage) { 
                drawing.drawImage(0,0,1178,798,0,0,920,512,ctx,bgImage);
            }
        
            let eps = entryPoints; //lib2d.reversed(entryPoints) // why
            eps.forEach(ep => {
                if(ep.shouldDraw()){
                    ep.draw(ctx);
                }
            });
        } else {
            // do nothing, nothing is loaded.
        }
    }

    function loop() { render(); requestAnimFrame(loop);}     
    function load() { 
        console.log(data);
        if(data.src) {
            bgImage = loadImage(data.src);
        }
        data.entryPoints.forEach( e => {
            entryPoints.push(new EntryPoint(e));
        });
        loop();
    } 

    // PUT YOUR EXPORTED JSON HERE
    data = {"entryPoints":[{"id":"EP1653213089422","name":"Typhon-2","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":76,"y":60},"_isHovered":false,"_isSelected":false,"_hoverOverride":true,"size":{"sizeX":168,"sizeY":36},"shape":"ROUNDEDRECT","link":"","text":"First","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":true,"_chunks":[{"x":134.23913043478262,"y":83,"text":"First"}],"elements":[{"id":"SH1653213095942","name":"Wyvern-3","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":340,"y":56},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":172,"sizeY":44},"shape":"RECT","link":"","text":"Second","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":true,"_chunks":[{"x":396.0652173913044,"y":83,"text":"Second"}]},{"id":"SH1653213106293","name":"Elf-4","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":32,"y":472},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":988,"sizeY":240},"shape":"ROUNDEDRECT","link":"","text":"class HitBox {\n        constructor(hitBoxX, hitBoxY, hitBoxSizeX, hitBoxSizeY ){}\n        areCentersToClose(first, a,second, b) {\n            let ax = first.posX+a.hitBoxX;\n            let ay = first.posY+a.hitBoxY;\n            let bx = second.posX+b.hitBoxX;\n            let by = second.posY+b.hitBoxY;\n            return  (this.absVal( (ax+(a.hitBoxSizeX >> 1))  - (bx + (b.hitBoxSizeX >> 1)) ) < ((a.hitBoxSizeX >>1) + (b.hitBoxSizeX >> 1))) &&\n                    (this.absVal( (ay+(a.hitBoxSizeY >> 1))  - (by + (b.hitBoxSizeY >> 1)) ) < ((a.hitBoxSizeY >> 1) + (b.hitBoxSizeY >> 1)));\n        }\n        absVal(val) { return (val < 0) ? -val : val; }\n    }","textSize":18,"textColor":"#444","textAlign":"CODE","fillColor":"#fff","isFilled":true,"_chunks":[{"x":37,"y":495,"text":"class HitBox {"},{"x":37,"y":513,"text":"        constructor(hitBoxX, hitBoxY, hitBoxSizeX, hitBoxSizeY ){}"},{"x":37,"y":531,"text":"        areCentersToClose(first, a,second, b) {"},{"x":37,"y":549,"text":"            let ax = first.posX+a.hitBoxX;"},{"x":37,"y":567,"text":"            let ay = first.posY+a.hitBoxY;"},{"x":37,"y":585,"text":"            let bx = second.posX+b.hitBoxX;"},{"x":37,"y":603,"text":"            let by = second.posY+b.hitBoxY;"},{"x":37,"y":621,"text":"            return  (this.absVal( (ax+(a.hitBoxSizeX >> 1))  - (bx + (b.hitBoxSizeX >> 1)) ) < ((a.hitBoxSizeX >>1) + (b.hitBoxSizeX >> 1))) &&"},{"x":37,"y":639,"text":"                    (this.absVal( (ay+(a.hitBoxSizeY >> 1))  - (by + (b.hitBoxSizeY >> 1)) ) < ((a.hitBoxSizeY >> 1) + (b.hitBoxSizeY >> 1)));"},{"x":37,"y":657,"text":"        }"},{"x":37,"y":675,"text":"        absVal(val) { return (val < 0) ? -val : val; }"},{"x":37,"y":693,"text":"    }"}]},{"id":"LN1653213142931","name":"Onocentaur-5","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":424,"y":100},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"startArrowStyle":"NONE","endArrowStyle":"ARROW","startArrowSize":"SMALL","endArrowSize":"SMALL","secondaryCords":[{"x":428,"y":468}],"tempStartCord":null,"tempCord":null,"cordsSet":true,"held":false},{"id":"LN1653213149078","name":"Psoglav-6","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":492,"y":100},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"startArrowStyle":"NONE","endArrowStyle":"ARROW","startArrowSize":"SMALL","endArrowSize":"SMALL","secondaryCords":[{"x":492,"y":296},{"x":696,"y":296}],"tempStartCord":null,"tempCord":{"x":696,"y":296},"cordsSet":true,"held":false},{"id":"SEP1653213156821","name":"Typhon-2-Humbaba-7","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":700,"y":284},"_isHovered":false,"_isSelected":false,"_hoverOverride":true,"size":{"sizeX":184,"sizeY":36},"shape":"ROUNDEDRECT","link":"","text":"SubEntry","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":true,"_chunks":[{"x":755.06,"y":307,"text":"SubEntry"}],"elements":[{"id":"LN1653213165342","name":"Hippocampus-8","color":"#000","strokeWidth":0.6,"lineStyle":"DOTTED","cords":{"x":796,"y":320},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"startArrowStyle":"NONE","endArrowStyle":"UNFILLED","startArrowSize":"SMALL","endArrowSize":"SMALL","secondaryCords":[{"x":800,"y":468}],"tempStartCord":null,"tempCord":null,"cordsSet":true,"held":false},{"id":"SH1653213175045","name":"Winged Lion-9","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":812,"y":384},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":76,"sizeY":28},"shape":"NONE","link":"","text":"More Text","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":true,"_chunks":[{"x":808.3,"y":403,"text":"More Text"}]},{"id":"SH1653213181443","name":"Chimera-10","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":744,"y":148},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":264,"sizeY":116},"shape":"PACKAGE","link":"","text":"Pack","textSize":15,"textColor":"#000","textAlign":"TOPLEFT","fillColor":"#fef3bd","isFilled":true,"_chunks":[{"x":749,"y":162,"text":"Pack"}]},{"id":"SH1653213200469","name":"Ophiotaurus-11","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":756,"y":192},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":224,"sizeY":56},"shape":"CLASS","link":"","text":"Class one","textSize":15,"textColor":"#000","textAlign":"TOPCENTER","fillColor":"#c4def6","isFilled":true,"_chunks":[{"x":827.983870967742,"y":206,"text":"Class one"}]},{"id":"SH1653213233610","name":"Huay Chay-12","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":580,"y":148},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":88,"sizeY":108},"shape":"DIAMOND","link":"","text":"Dia","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":true,"_chunks":[{"x":604.5,"y":207,"text":"Dia"}]},{"id":"SH1653213247477","name":"Fachan-13","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":60,"y":336},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":120,"sizeY":72},"shape":"CIRCLE","link":"","text":"Circ","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":true,"_chunks":[{"x":98.38235294117646,"y":377,"text":"Circ"}]},{"id":"SH1653213262908","name":"Monocerus-14","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":492,"y":404},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":100,"sizeY":56},"shape":"OVAL","link":"","text":"Oval","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":true,"_chunks":[{"x":520.2142857142857,"y":437,"text":"Oval"}]},{"id":"SH1653213288332","name":"Kappa-15","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":84,"y":160},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":136,"sizeY":104},"shape":"DATABASE","link":"","text":"DB","textSize":15,"textColor":"#000","textAlign":"TOPCENTER","fillColor":"#fff","isFilled":true,"_chunks":[{"x":137.3421052631579,"y":174,"text":"DB"}]}],"isHoverable":true,"hoverBorderColor":"#77DD66","isSelectable":true,"isSelectedByDefault":false,"selectedFillColor":"#eee","selectedBorderColor":"#265828","_display":true}],"isHoverable":true,"hoverBorderColor":"#77DD66","isSelectable":true,"isSelectedByDefault":false,"selectedFillColor":"#eee","selectedBorderColor":"#265828","_display":true},{"id":"EP1653213302844","name":"Fairy-16","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":256,"y":184},"_isHovered":false,"_isSelected":true,"_hoverOverride":true,"size":{"sizeX":120,"sizeY":48},"shape":"ROUNDEDRECT","link":"","text":"Second EP","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":true,"_chunks":[{"x":276.7352941176471,"y":213,"text":"Second EP"}],"elements":[{"id":"SH1653213319035","name":"Hippogriff-17","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":244,"y":360},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":136,"sizeY":80},"shape":"DATABASE","link":"","text":"DB2","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":true,"_chunks":[{"x":293.7631578947368,"y":405,"text":"DB2"}]},{"id":"LN1653213328603","name":"Leviathan-18","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":308,"y":232},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"startArrowStyle":"FILLED","endArrowStyle":"ARROW","startArrowSize":"HUGE","endArrowSize":"MEDIUM","secondaryCords":[{"x":308,"y":356}],"tempStartCord":null,"tempCord":null,"cordsSet":true,"held":false}],"isHoverable":true,"hoverBorderColor":"#77DD66","isSelectable":true,"isSelectedByDefault":false,"selectedFillColor":"#eee","selectedBorderColor":"#265828","_display":true}],"_selecting":true,"_placing":false,"_defaultValues":{"width":1024,"height":800,"scale":4,"color":"#000","strokeWidth":0.6,"textColor":"#000","textSize":15,"fillColor":"#fff","hoverBorderColor":"#77DD66","selectedFillColor":"#eee","selectedBorderColor":"#265828","backgroundColor":"#F8F8F8"},"src":null,"version":"1.0.0"}
    // 

    load();

</script>










