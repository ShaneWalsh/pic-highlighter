
<!-- 
    Hover on entrypoints to see elements.
    Left click on entrypoints to toggle selected state.
    Right on elements to copy link, if no link then the text will be copied instead.
    Pic Highlighter V1.0.0
 -->

<canvas id="canvas" width="920" height="512" ></canvas>

<script>
    const requestAnimFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || // this redraws the canvas when the browser is updating. Crome 18 is execllent for canvas, makes it much faster by using os
						   window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame
						   || function(callback) { window.setTimeout(callback,1000/60);}; //moz firefox 4 up, o Opera, ms IE 9, not standardised yet so need different browsers

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = 'green';
    ctx.fillRect(10, 10, 150, 100);

    let data = null;
    let entryPoints = [];
    let bgImage = null;

    const lib2d = {
        loadImage({src}) {
            let imga = new Image();
            if(src.indexOf("data:image") > -1){
                imga.src = src;
            }
            return imga;
        },
        reversed(array){
            let arr = [];
            for(let i = (array.length-1); i > -1;i--){
                arr.push(array[i])
            }
            return arr;
        },
        pointInsideSprite(point, sprite) {
            if(point.x > sprite.x && point.x < (sprite.x+sprite.sizeX) ){
                if(point.y > sprite.y && point.y < (sprite.y+sprite.sizeY)){
                    return true;
                }
            }
        }
    }

    // Drawing
    const drawing = {
        drawBorder(x,y,sizeX,sizeY, width,color, fill, style, ctx) {
            ctx.save();     
            ctx.beginPath()
            if(style === "DOTTED") {
            ctx.setLineDash([5, 5]);
            }
            if (fill) {
            ctx.fillStyle = fill
            ctx.fillRect(x,y,sizeX,sizeY);
            }
            ctx.lineWidth = width;
            ctx.strokeStyle = color;
            ctx.strokeRect(x,y,sizeX,sizeY);
            
            ctx.closePath()
            ctx.restore();
        },
        drawLine(x,y,xx,yy, width, color, style, ctx) {
            ctx.save();    
            ctx.beginPath();
            if(style === "DOTTED") {
            ctx.setLineDash([5, 5]);
            }
            ctx.lineWidth = width;
            ctx.moveTo(x, y);
            ctx.lineTo(xx, yy);
            ctx.strokeStyle = color;
            ctx.stroke();
            ctx.closePath();
            ctx.restore();
        },
        drawArrowHeads(x,y,xx,yy, width,color,ctx, start, end, startStyle,endStyle,startSize,endSize) {
            // draw the starting arrowhead
            if(start){
                var startRadians=Math.atan((yy-y)/(xx-x));
                startRadians+=((xx>x || xx === x)?-90:90)*Math.PI/180;
                this.drawArrowHead(x,y,startRadians,width,color,ctx,startStyle,startSize);
            }
            // draw the ending arrowhead
            if(end){
                var endRadians=Math.atan((yy-y)/(xx-x));
                endRadians+=((xx>x || xx === x)?90:-90)*Math.PI/180;
                this.drawArrowHead(xx,yy,endRadians,width,color,ctx,endStyle,endSize);
            }
        },
        drawArrowHead (x,y,radians, width,color,ctx, style, size) {
            ctx.save();
            ctx.beginPath();
            ctx.lineWidth = width;
            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.translate(x,y);
            ctx.rotate(radians);
            ctx.moveTo(0,0);
            let sizes = this.getSize(size);
            if(style === "ARROW"){
                ctx.lineTo(sizes.nose,sizes.wing);
                ctx.lineTo(0,0);
                ctx.lineTo(sizes.nose*-1,sizes.wing);
            } else { // Full or Empty so draw the entire arrow
                ctx.lineTo(sizes.nose,sizes.wing);
                ctx.lineTo(sizes.nose*-1,sizes.wing);
            }
            ctx.closePath();
            ctx.stroke();
            if(style === "FILLED"){ ctx.fill(); }
            if(style === "UNFILLED"){ ctx.fillStyle = "#FFF";ctx.fill(); }
            ctx.restore();
        },
        getSize(size) {
            if(size === "TINY"){
                return {nose:5,wing:6}
            } else   if(size === "SMALL"){
                return {nose:5,wing:9}
            } else   if(size === "MEDIUM"){
                return {nose:6,wing:12 }
            } else   if(size === "LARGE"){
                return {nose:10,wing:20}
            } else   if(size === "HUGE"){
                return {nose:15,wing:30}
            }
            return {nose:5,wing:10};
        },
        drawCircle(x, y, radius, fill, stroke, strokeWidth, style, ctx) {
            ctx.save();  
            ctx.beginPath()
            if(style === "DOTTED") {
            ctx.setLineDash([5, 5]);
            }
            ctx.arc(x, y, radius, 0, 2 * Math.PI, false)
            if (fill) {
            ctx.fillStyle = fill
            ctx.fill()
            }
            if (stroke) {
            ctx.lineWidth = strokeWidth
            ctx.strokeStyle = stroke
            ctx.stroke()
            }
            ctx.closePath()
            ctx.restore();
        },
        drawShape(cords, width, color, fill, style, ctx) {
            ctx.save();  
            ctx.beginPath();
            ctx.lineWidth = width;
            if(style === "DOTTED") {
                ctx.setLineDash([5, 5]);
            }
            let cord1=cords[0];
            ctx.moveTo(cord1.x, cord1.y);
            for(let i =1; i < cords.length;i++){
                cord1 = cords[i];
                ctx.lineTo(cord1.x, cord1.y);
            }
            ctx.closePath()
            if(fill){
                ctx.fillStyle = fill;
                ctx.fill();
            }
            ctx.strokeStyle = color;
            ctx.stroke();
            ctx.restore();
        },
        drawRoundRect (x, y, sizeX,sizeY, width, radius, color, fill, style, ctx) {
            ctx.save();  
            ctx.beginPath();
            if (typeof radius === 'undefined') {
                radius = 5;
            }
            if (typeof radius === 'number') {
                radius = {tl: radius, tr: radius, br: radius, bl: radius};
            } else {
                var defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0};
                for (var side in defaultRadius) {
                    radius[side] = radius[side] || defaultRadius[side];
                }
            }
            if( style === "DOTTED" ) {
                ctx.setLineDash([5, 5]);
            }
            ctx.lineWidth = width;
            ctx.moveTo(x + radius.tl, y);
            ctx.lineTo(x + sizeX - radius.tr, y);
            ctx.quadraticCurveTo(x + sizeX, y, x + sizeX, y + radius.tr);
            ctx.lineTo(x + sizeX, y + sizeY - radius.br);
            ctx.quadraticCurveTo(x + sizeX, y + sizeY, x + sizeX - radius.br, y + sizeY);
            ctx.lineTo(x + radius.bl, y + sizeY);
            ctx.quadraticCurveTo(x, y + sizeY, x, y + sizeY - radius.bl);
            ctx.lineTo(x, y + radius.tl);
            ctx.quadraticCurveTo(x, y, x + radius.tl, y);
            ctx.closePath();
            if (fill) {
                ctx.fillStyle = fill;
                ctx.fill();
            }
            ctx.strokeStyle = color;
            ctx.stroke();
            ctx.restore();
        },
        drawOval (x, y, sizeX,sizeY, width, color, fill, style, ctx) {
            ctx.save();  
            ctx.beginPath();
            if( style === "DOTTED" ) {
                ctx.setLineDash([5, 5]);
            }
            ctx.lineWidth = width;
            ctx.ellipse(x, y, sizeX, sizeY, 0, 0, Math.PI*2);
            if (fill) {
                ctx.fillStyle = fill;
                ctx.fill();
            }
            ctx.strokeStyle = color;
            ctx.stroke();
            ctx.restore();
        },
        drawDatabase(x, y, sizeX,sizeY, width, color, fill, style, ctx) {
            ctx.save();  
            ctx.beginPath();
            if( style === "DOTTED" ) {
                ctx.setLineDash([5, 5]);
            }
            ctx.lineWidth = width;
            ctx.strokeStyle = color;
            ctx.fillStyle = fill;

            ctx.ellipse(x, y+(sizeY/2), sizeX, sizeY/2, 0, 0, Math.PI*2);
            if (fill) {ctx.fill();}
            ctx.stroke();
            // this rect is drawn over the first ellipse to add the sides
            ctx.beginPath();
            ctx.strokeRect(x-sizeX,y-(sizeY/2),sizeX*2,sizeY);
            // finally the top ellipse
            ctx.beginPath();
            ctx.ellipse(x, y-(sizeY/2), sizeX, sizeY/2, 0, 0, Math.PI*2);
            if (fill) {
                ctx.fill();
                ctx.fillRect(x-sizeX,y-(sizeY/2),sizeX*2,sizeY);
            }
            ctx.stroke();
            ctx.restore();
        },
        writeInPixels(x, y, size, text, color, align, cords, sizes, ctx){
            //ctx.font = size + "px 'Century Gothic'";
            if(align === "SIDEBARLEFT"){
                let newX = cords.x + (y-cords.y);
                let newY = cords.y + sizes.sizeY
                ctx.save();
                ctx.font = size + "px 'sans-serif'";
                ctx.fillStyle = color;
                ctx.translate( newX, newY);
                ctx.rotate(-Math.PI/2);
                ctx.fillText(text, 5, 0);
                ctx.restore();
            } else if(align === "SIDEBARCENTER"){
                let newX = cords.x + (y-cords.y);
                let newY = cords.y + (sizes.sizeY/2)
                ctx.save();
                ctx.font = size + "px 'sans-serif'";
                ctx.fillStyle = color;
                ctx.translate( newX, newY);
                ctx.rotate(-Math.PI/2);
                ctx.textAlign = 'center';
                ctx.fillText(text, 5, 0);
                ctx.restore();
            } else if (align === "CENTER" || align === "TOPCENTER") {
                ctx.save();
                ctx.font = size + "px 'sans-serif'";
                ctx.fillStyle = color;
                let textSpace = ctx.measureText(text).width;
                ctx.fillText(text, cords.x+ ((sizes.sizeX-textSpace)/2), y);
                ctx.restore();
            } else {
                ctx.save();
                ctx.font = size + "px 'sans-serif'";
                ctx.fillStyle = color;
                ctx.fillText(text, x, y);
                ctx.restore();
            }
        },
        /**
         * Calc how many chunks there will be
         * Then calculate the postions of them, factoring in alignment
         * OOS shape support.
         * returns chunks:[{x,y,text}]
         */
        calculateChunks (x, y, sizeX, sizeY, textSize, text, align, shape) {
            if(sizeX > 5 && sizeY > 2) {
                if(align === "CODE"){
                    let texts = text.split("\n");
                    let chunks = [];
                    let topPadding = Math.round((textSize/100) * 130);
                    for(let i = 0; i < texts.length;i++) {
                        chunks.push({x:x + 5,y:y+topPadding+(i*textSize),text:texts[i] });
                    }
                    return chunks
                }
                text = text.trim();
                const len = text.length;
                let maxLen = Math.floor(sizeX / (textSize/2)) + Math.floor(sizeX/100);
                if(align === "SIDEBARLEFT" || align === "SIDEBARCENTER") { // the size is actually measured by height when doing sidebar
                maxLen = Math.floor(sizeY / (textSize/2)) + Math.floor(sizeY/100);
                }
                let curLen = 0;
                let texts = [];
                // work out the chunks of text based on the space
                for(let i =0; curLen < len; i++) {
                let max = (curLen+maxLen >= len)?len:curLen+maxLen;
                while(text.charAt(max)!== ' ' && max < len && max > 2){max--;}
                let txt = text.substring(curLen,max); //.trim();

                // Check for newlines in this text and split on it.
                let newLineSplits = txt.split('\n');// .map(t => t.trim());
                if(newLineSplits.length === 1){
                    curLen = max;
                } else {
                    curLen = curLen + newLineSplits[0].length + 1 // +1 to get past the \n
                }
                texts.push(newLineSplits[0]);
                if(i > 10000) return []; // sanity fallback
                }
                texts = texts.map(t => t.trim()).filter(t => t.length > 0); // trim everything. We cannot do it above, because we need the full lenghts for measuring
                // then do the alignment
                let chunks = [];
                // for standard style
                if(align === "TOPLEFT" || align === "SIDEBARLEFT" || align === "SIDEBARCENTER") {
                let topPadding = Math.round((textSize/100) * 90);
                for(let i = 0; i < texts.length;i++) {
                    chunks.push({x:x + 5,y:y+topPadding+(i*textSize),text:texts[i] });
                }
                } else if(align === "CENTER") {
                // TODO
                let halfText = textSize/2;
                let startingY = 5 + (sizeY/2);
                let startingX = (sizeX/2);
                // Lets work out the starting Y
                if(texts.length % 2 === 0 && texts.length > 1){ // even
                    let even = texts.length/2;
                    startingY = (startingY+halfText) - (textSize * even);
                } else if((texts.length % 2 === 1 && texts.length > 1)){
                    let odd = Math.floor(texts.length/2); // round down.
                    startingY = startingY - (textSize * odd);
                }
                // X will be worked out independently for each line
                for(let i = 0; i < texts.length;i++) {
                    let txt = texts[i];
                    let centeringAdjustment = 0;
                    if(txt.length < 10) centeringAdjustment = halfText;
                    let percentage = ((txt.length/maxLen)*100); // whats this text % of the total length is this string? Then half it.
                    let widthOffset = ((sizeX/2)/100)*percentage; // now take this half percentage from the startingX which is centered.
                    chunks.push({x:x+(startingX - widthOffset)-centeringAdjustment ,y:y+startingY+(i*textSize),text:texts[i] });
                }
                } else if(align === "TOPCENTER") {
                // TODO
                let halfText = textSize/2;
                let startingY = Math.round((textSize/100) * 90);
                let startingX = (sizeX/2);
                // X will be worked out independently for each line
                for(let i = 0; i < texts.length;i++) {
                    let txt = texts[i];
                    let centeringAdjustment = 0;
                    if(txt.length < 10) centeringAdjustment = halfText;
                    let percentage = ((txt.length/maxLen)*100); // whats this text % of the total length is this string? Then half it.
                    let widthOffset = ((sizeX/2)/100)*percentage; // now take this half percentage from the startingX which is centered.
                    chunks.push({x:x+(startingX - widthOffset)-centeringAdjustment ,y:y+startingY+(i*textSize),text:texts[i] });
                }
                }

                return chunks;
            } else {
                return [];
            }
        }
    }

    /*****************************************************************************************************************************/
    /*******************************************         Mouse  ******************************************************************/
    /*****************************************************************************************************************************/

    const mouseFunctions = {
        mouseX:0,
        mouseY:0,
        updateMousePosition(e){
            const v= this.getOffset(canvas);
            mouseX =  Math.floor(e.pageX)-v.left;
            mouseY =  Math.floor(e.pageY)-v.top;
            lib2d.reversed(getCurrentEntryPoints()).forEach(e => {
                e.setHovered(lib2d.pointInsideSprite({x:mouseX,y:mouseY},e.hitboxes()));
            })
	    },

        mouseClick(e){
            const v= this.getOffset(canvas);
            mouseX =  Math.floor(e.pageX)-v.left;
            mouseY =  Math.floor(e.pageY)-v.top;
            if(e.button == 0){ // 0 = left click
                let rev = lib2d.reversed(getCurrentEntryPoints());
                for(let i = 0; i < rev.length; i++){
                    if(lib2d.pointInsideSprite({x:mouseX,y:mouseY},rev[i].hitboxes())){
                        rev[i].toggleSelected(); 
                        break;
                    }
                }
            }
        },

        mouseClickRelease(e){},

        // this is just a catch for the context menu, to prevent it from appearing.
        rightClickContext(e){ 
            e.preventDefault();
            const v= this.getOffset(canvas);
            mouseX =  Math.floor(e.pageX)-v.left;
            mouseY =  Math.floor(e.pageY)-v.top;
            let rev = lib2d.reversed(getCurrentEntryPoints());
            for(let i = 0; i < rev.length; i++){
                let ep = rev[i];
                if(lib2d.pointInsideSprite({x:mouseX,y:mouseY},ep.hitboxes())){
                    ep.copylink();
                    return;
                }
                if(ep._isSelected) { // if its not selected then we should not be able to see its elements for right clicking, right?
                    let revElements = lib2d.reversed(ep.elements);
                    for(let i = 0; i < revElements.length; i++){
                        if(lib2d.pointInsideSprite({x:mouseX,y:mouseY},revElements[i].hitboxes())){
                            revElements[i].copylink();
                            return;
                        }
                    }
                }
            }
        },

        doubleClick(e){},
        getOffset(el) {
            const rect = el.getBoundingClientRect();
            return {
                left: rect.left + window.scrollX,
                top: rect.top + window.scrollY
            }
        }

    }
    document.getElementById('canvas').addEventListener("mousemove", mouseFunctions.updateMousePosition.bind(mouseFunctions), false);
    document.getElementById('canvas').addEventListener("dblclick", mouseFunctions.doubleClick.bind(mouseFunctions), false);
    document.getElementById('canvas').addEventListener("mousedown", mouseFunctions.mouseClick.bind(mouseFunctions), false);
    document.getElementById('canvas').addEventListener("mouseup", mouseFunctions.mouseClickRelease.bind(mouseFunctions), false);
    document.getElementById('canvas').addEventListener("contextmenu", mouseFunctions.rightClickContext.bind(mouseFunctions), false);


    /*****************************************************************************************************************************/
    /*******************************************   entrypoints  ******************************************************************/
    /*****************************************************************************************************************************/
    
    class DiagramElement {
        id= "replacement";
        name = 'replacement'; 
        color = '#bbb';
        strokeWidth=.4;
        lineStyle = "FULL";
        cords = {x:0,y:0};

        constructor(options) {
            Object.assign(this, options);
        }

        hitboxes(){return {x:0,y:0,sizeX:0,sizeY:0}}
    }

    class Shape extends DiagramElement {
        size = {sizeX:0,sizeY:0};
        shape = "RECT";
        link="";
        text="";
        textSize = 15;
        textColor = '#333'
        textAlign = "CENTER";
        fillColor = "#FFFFFF";
        isFilled =false;
        _chunks = [];

        constructor(options) {
            super();
            Object.assign(this, options);
        }

        getFill() {
            return (this.isFilled)?this.fillColor:null;
        }

        getColor() {
            return this.color;
        }
        // Copy the link if there is one, else copy the text.
        copylink(){
            if(this.link && this.link !== ""){
                var input = document.createElement('input');
                input.setAttribute('value', this.link);
                document.body.appendChild(input);
                input.select();
                var result = document.execCommand('copy');
                document.body.removeChild(input);
                return result;
            } else if(this.text && this.text !== ""){
                var input = document.createElement('input');
                input.setAttribute('value', this.text);
                document.body.appendChild(input);
                input.select();
                var result = document.execCommand('copy');
                document.body.removeChild(input);
                return result;
            }
        }

        draw(ctx) {
            if(this.shape === "RECT") {
                drawing.drawBorder( this.cords.x,this.cords.y,this.size.sizeX,this.size.sizeY,this.strokeWidth,this.color,this.getFill(),this.lineStyle,ctx )
            } else if(this.shape === "ROUNDEDRECT") {
                drawing.drawRoundRect( this.cords.x, this.cords.y, this.size.sizeX, this.size.sizeY, this.strokeWidth, 5, this.getColor(), this.getFill(), this.lineStyle, ctx )
            } else if(this.shape === "OVAL") {
                drawing.drawOval( this.cords.x + this.size.sizeX/2 , this.cords.y + this.size.sizeY/2, this.size.sizeX/2, this.size.sizeY/2, this.strokeWidth, this.getColor(), this.getFill(), this.lineStyle, ctx )
            } else if(this.shape === "DATABASE") {
                drawing.drawDatabase( this.cords.x + this.size.sizeX/2 , this.cords.y + this.size.sizeY/2, this.size.sizeX/2, this.size.sizeY/2, this.strokeWidth, this.getColor(), this.getFill(), this.lineStyle, ctx )
            } else if(this.shape === "DIAMOND") {
                const left = {x:this.cords.x, y :this.cords.y+ (this.size.sizeY/2) };
                const top = {x:this.cords.x + (this.size.sizeX/2), y :this.cords.y };
                const right = {x:this.cords.x + this.size.sizeX, y :this.cords.y+ (this.size.sizeY/2) };
                const bottom = {x:this.cords.x+ (this.size.sizeX/2), y :this.cords.y+ this.size.sizeY };

                drawing.drawShape([{x:left.x,y:left.y},{x:top.x,y:top.y},{x:right.x,y:right.y},{x:bottom.x,y:bottom.y},{x:left.x,y:left.y}], this.strokeWidth, this.color, this.getFill(), this.lineStyle, ctx)
                // TODO replace with a drawshape method, takes cords, connects the dots with lines, fills with provided fill value
            } else if(this.shape === "CIRCLE") {
                drawing.drawCircle( this.cords.x + (this.size.sizeX/2),this.cords.y + (this.size.sizeY/2),this.size.sizeX/2,this.getFill(),this.color,this.strokeWidth,this.lineStyle,ctx )
            }
            this._chunks.forEach(_chunks => {
                // writeInPixels(this.cords.x+this.size.sizeX/2, this.cords.y+this.size.sizeY/2,15,this.text,this.color,ctx);
                drawing.writeInPixels(_chunks.x, _chunks.y, this.textSize, _chunks.text,this.textColor,this.textAlign, this.cords, this.size, ctx);
            })
        }

        drawHover(ctx){
            drawing.drawBorder(this.cords.x,this.cords.y,this.size.sizeX,this.size.sizeY,this.strokeWidth, this.getColor(), null, this.lineStyle, ctx)
        }

        hitboxes(){return {...this.cords,...this.size}}
        
    }

    class EntryPoint extends Shape {
        // All of the elements related to this entrypoint
        elements=[]
        isHoverable =true; // if not hoverable, it will not highlight the box when hovered over, and not display the elements(TODO extract second part to new Variable?).
        hoverBorderColor = "#000";
        isSelectable =true;
        isSelectedByDefault = false; // when this is true, it will be selected on first draw. Could be used as a BG in absence of an image.
        selectedFillColor = "#FFFFFF"; // when this is true, and not selected, a light colored outline with display where is.
        selectedBorderColor = "#FFFFFF"; // when this is true, and not selected, a light colored outline with display where is.
        
        _isHovered=false;
        _isSelected=false;
        _hoverOverride=false;// when I deselect I want to override the hover.

        constructor(options) {
            super();
            Object.assign(this, options);
            let elementsCon = [];
            for(let el of this.elements) {
                if(el.id.startsWith("LN")) {
                    elementsCon.push(new Line(el));
                } else if(el.id.startsWith("SH")){
                    elementsCon.push(new Shape(el));
                } else if(el.id.startsWith("SEP")){
                    elementsCon.push(new EntryPoint(el));
                }
            }
            this.elements = elementsCon;
            this._isSelected = this.isSelectedByDefault;
        }

        setHovered(bool){this._isHovered= bool; if(!this._isHovered){this._hoverOverride = false}}
        toggleSelected(){
            this._isSelected = !this._isSelected; 
            this._hoverOverride = true;
            if(this._isSelected === false){
                let sep = this.getSEP();
                sep.forEach(ep => {
                    ep.toggleSelected(false)
                })
            }
        }
        
        shouldDraw(){
            return true;
        }

        shouldDisplayElements(){
            return (this._isHovered && !this._hoverOverride) || this._isSelected;
        }

        // TEXT OOS
        draw(ctx) {
            if(this.shouldDisplayElements()){
                this.elements.forEach( (el) => {
                    el.draw(ctx)
                });
            }
            super.draw(ctx);
            if(this._isHovered && !this._hoverOverride){
                this.drawHover(ctx);
            }
        }
        
        getFill() {
            if(this.isFilled){
                if(this._isSelected){
                    return this.selectedFillColor;
                } else {
                    return this.fillColor;
                }
            }
            return null;
        }

        getColor() {
            if(this._isHovered) {
                return this.hoverBorderColor;
            } else if(this._isSelected){
                return this.selectedBorderColor;
            } else {
                return this.color;
            }
        }

        // Find all of the sub entry points and return then.
        getEP(){
            let arr = [this];
            if(this._isSelected) {
                arr = arr.concat(this.getSEP())
            }
            return arr;
        }
        getSEP(){
            let arr = [];
            this.elements.forEach(element => {
                if(element instanceof EntryPoint){
                    arr = arr.concat(element.getEP())
                }
            });
            return arr;
        }
    }

    class Line extends DiagramElement {
        startArrowStyle = "NONE";
        endArrowStyle = "NONE";    
        startArrowSize = "SMALL";
        endArrowSize = "SMALL";
        secondaryCords = [];

        constructor(options) {
            super();
            Object.assign(this, options);
        }
    
        draw(ctx){
            let drawer = drawing.drawLine;
            if(!this.cordsSet && this.tempStartCord && this.tempCord){
                drawer( this.tempStartCord.x, this.tempStartCord.y, this.tempCord.x, this.tempCord.y, this.strokeWidth, this.color, this.lineStyle, ctx)
            } else {
                let first = this.cords;
                for(let i = 0; i < this.secondaryCords.length; i++){
                    let sec = this.secondaryCords[i];
                    drawer(
                        first.x,first.y,sec.x,sec.y,this.strokeWidth,this.color,this.lineStyle,ctx
                    )
                    first = sec;
                }
                // draw the arrow heads for the two ends
                if(this.secondaryCords.length > 1) {
                    if(this.startArrowStyle !== "NONE"){
                        drawing.drawArrowHeads(this.cords.x,this.cords.y,this.secondaryCords[0].x,this.secondaryCords[0].y,this.strokeWidth,this.color,ctx,
                            true,false, this.startArrowStyle, this.endArrowStyle,this.startArrowSize,this.endArrowSize);
                    }
                    if(this.endArrowStyle !== "NONE") {
                        let secondLast = this.secondaryCords[this.secondaryCords.length-2];
                        let last = this.secondaryCords[this.secondaryCords.length-1];
                        drawing.drawArrowHeads(secondLast.x,secondLast.y,last.x,last.y,this.strokeWidth,this.color,ctx,
                            false,true, this.startArrowStyle, this.endArrowStyle,this.startArrowSize,this.endArrowSize);
                    }
                } else {
                    drawing.drawArrowHeads(this.cords.x,this.cords.y,first.x,first.y,this.strokeWidth,this.color,ctx,
                        (this.startArrowStyle !== "NONE"), (this.endArrowStyle !== "NONE"), 
                        this.startArrowStyle, this.endArrowStyle,this.startArrowSize,this.endArrowSize);
                }
                
                if(this.held && this.tempCord){
                    drawer(
                        first.x, first.y, this.tempCord.x, this.tempCord.y, this.strokeWidth, this.color, this.lineStyle, ctx
                    )
                }
            }
        }
    }

    class HitBox {
        constructor(hitBoxX, hitBoxY, hitBoxSizeX, hitBoxSizeY ){}
        areCentersToClose(first, a,second, b) {
            let ax = first.posX+a.hitBoxX;
            let ay = first.posY+a.hitBoxY;
            let bx = second.posX+b.hitBoxX;
            let by = second.posY+b.hitBoxY;
            return  (this.absVal( (ax+(a.hitBoxSizeX >> 1))  - (bx + (b.hitBoxSizeX >> 1)) ) < ((a.hitBoxSizeX >>1) + (b.hitBoxSizeX >> 1))) &&
                    (this.absVal( (ay+(a.hitBoxSizeY >> 1))  - (by + (b.hitBoxSizeY >> 1)) ) < ((a.hitBoxSizeY >> 1) + (b.hitBoxSizeY >> 1)));
        }
        absVal(val) { return (val < 0) ? -val : val; }
    }
    
    function getCurrentEntryPoints(){
        let array = [];
        entryPoints.forEach(ep => {
            array = array.concat(ep.getEP())
        });
        return array;
    }

    // Main logic block for rendering.
    function render() {
        if(data) {
            ctx.canvas.width  = data._defaultValues.width;
            ctx.canvas.height = data._defaultValues.height;
            ctx.clearRect(0,0, data._defaultValues.width, data._defaultValues.height); // clear the rect
            ctx.fillStyle = data._defaultValues.backgroundColor;
            ctx.fillRect(0,0,data._defaultValues.width, data._defaultValues.height);
            if(bgImage) { 
                drawing.drawImage(0,0,1178,798,0,0,920,512,ctx,bgImage);
            }
        
            let eps = entryPoints; //lib2d.reversed(entryPoints) // why
            eps.forEach(ep => {
                if(ep.shouldDraw()){
                    ep.draw(ctx);
                }
            });
        } else {
            // do nothing, nothing is loaded.
        }
    }

    function loop() { render(); requestAnimFrame(loop);}     
    function load() { 
        console.log(data);
        if(data.src) {
            bgImage = loadImage(data.src);
        }
        data.entryPoints.forEach( e => {
            entryPoints.push(new EntryPoint(e));
        });
        loop();
    } 

    // PUT YOUR EXPORTED JSON HERE
    data = {"entryPoints":[{"id":"EP1652776831937","name":"Aspidochelone-0","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":732,"y":456},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":72,"sizeY":28},"shape":"ROUNDEDRECT","link":"","text":"Index","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fad0c3","isFilled":true,"_chunks":[{"x":740.5,"y":475,"text":"Index"}],"elements":[{"id":"SH1652776885259","name":"Cacus-1","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":528,"y":276},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":140,"sizeY":96},"shape":"RECT","link":"","text":"Deployer","textSize":15,"textColor":"#000","textAlign":"TOPCENTER","fillColor":"#fff","isFilled":false,"_chunks":[{"x":561.0263157894736,"y":290,"text":"Deployer"}]},{"id":"SH1652776912926","name":"Humbaba-2","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":0,"y":0},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":0,"sizeY":0},"shape":"RECT","link":"","text":"","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":false,"_chunks":[]},{"id":"SH1652776932634","name":"Hellhound-4","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":692,"y":296},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":100,"sizeY":28},"shape":"NONE","link":"","text":"Index Creation","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":false,"_chunks":[{"x":692,"y":315,"text":"Index Creation"}]},{"id":"SH1652777026423","name":"Ghoul-6","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":0,"y":0},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":0,"sizeY":0},"shape":"RECT","link":"","text":"","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":false,"_chunks":[]},{"id":"SH1652777118604","name":"Basilisk-8","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":548,"y":168},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":104,"sizeY":28},"shape":"RECT","link":"","text":"Domain dsl","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":false,"_chunks":[{"x":562.8571428571429,"y":187,"text":"Domain dsl"}]},{"id":"SH1652778787816","name":"Pegasus-12","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":512,"y":304},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":184,"sizeY":24},"shape":"RECT","link":"","text":"CapIndexSearchSchema","textSize":15,"textColor":"#000","textAlign":"TOPLEFT","fillColor":"#fff","isFilled":true,"_chunks":[{"x":517,"y":318,"text":"CapIndexSearchSchema"}]},{"id":"SH1652778916125","name":"Griffin-13","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":756,"y":168},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":188,"sizeY":24},"shape":"RECT","link":"","text":"SearchSchemaCreator","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":false,"_chunks":[{"x":781.3076923076924,"y":185,"text":"SearchSchemaCreator"}]},{"id":"LN1652779046829","name":"Ushi-oni-15","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":756,"y":180},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"startArrowStyle":"NONE","endArrowStyle":"FILLED","startArrowSize":"SMALL","endArrowSize":"SMALL","secondaryCords":[{"x":656,"y":180},{"x":656,"y":276}],"tempStartCord":null,"tempCord":null,"cordsSet":true,"held":false},{"id":"SH1652779064350","name":"Teju Jagua-16","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":664,"y":156},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":84,"sizeY":12},"shape":"NONE","link":"","text":"IndexedX Feature","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":false,"_chunks":[{"x":667.9545454545455,"y":159.5,"text":"IndexedX"},{"x":671.7727272727273,"y":174.5,"text":"Feature"}]},{"id":"SH1652783067995","name":"Psoglav-17","color":"#b80000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":332,"y":444},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":188,"sizeY":28},"shape":"RECT","link":"","text":"CapSearchIndexService","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#c1e1c5","isFilled":true,"_chunks":[{"x":350.0769230769231,"y":463,"text":"CapSearchIndexService"}]},{"id":"SH1652783121874","name":"Chimera-18","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":96,"y":548},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":172,"sizeY":28},"shape":"RECT","link":"","text":"CapSearchEndpoint","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":false,"_chunks":[{"x":118.43478260869566,"y":567,"text":"CapSearchEndpoint"}]},{"id":"SH1652783483416","name":"Scorpion Man-25","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":216,"y":208},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":148,"sizeY":20},"shape":"NONE","link":"","text":"@Indexed","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":false,"_chunks":[{"x":252.89999999999998,"y":223,"text":"@Indexed"}]},{"id":"LN1652783550129","name":"Calygreyhound-26","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":520,"y":460},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"startArrowStyle":"NONE","endArrowStyle":"ARROW","startArrowSize":"SMALL","endArrowSize":"SMALL","secondaryCords":[{"x":732,"y":468}],"tempStartCord":null,"tempCord":null,"cordsSet":true,"held":false},{"id":"SH1652783575383","name":"Cyclops-27","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":536,"y":436},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":128,"sizeY":24},"shape":"NONE","link":"","text":"Index","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":false,"_chunks":[{"x":574.7222222222222,"y":453,"text":"Index"}]},{"id":"SH1652783583915","name":"Serpopard-28","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":540,"y":468},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":112,"sizeY":20},"shape":"NONE","link":"","text":"Search/Query","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":false,"_chunks":[{"x":551.2,"y":483,"text":"Search/Query"}]},{"id":"SH1652784080929","name":"Cockatrice-29","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":352,"y":368},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":48,"sizeY":8},"shape":"NONE","link":"","text":"Index","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":false,"_chunks":[{"x":348.5,"y":377,"text":"Index"}]},{"id":"SH1652784089333","name":"Calygreyhound-30","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":184,"y":496},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":72,"sizeY":16},"shape":"NONE","link":"","text":"Search","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":false,"_chunks":[{"x":188.5,"y":509,"text":"Search"}]},{"id":"SH1652784232199","name":"Elf-31","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":696,"y":416},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":244,"sizeY":152},"shape":"RECT","link":"","text":"Solr/DSE/In Mem","textSize":15,"textColor":"#000","textAlign":"TOPCENTER","fillColor":"#fff","isFilled":false,"_chunks":[{"x":764.1764705882354,"y":430,"text":"Solr/DSE/In Mem"}]},{"id":"SH1652784453034","name":"Longma-32","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":388,"y":164},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":132,"sizeY":28},"shape":"RECT","link":"","text":"Transformation","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":false,"_chunks":[{"x":402.66666666666663,"y":183,"text":"Transformation"}]},{"id":"LN1652784476980","name":"Imp-33","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":384,"y":208},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"startArrowStyle":"NONE","endArrowStyle":"UNFILLED","startArrowSize":"SMALL","endArrowSize":"SMALL","secondaryCords":[{"x":388,"y":176},{"x":344,"y":188},{"x":224,"y":272}],"tempStartCord":null,"tempCord":null,"cordsSet":true,"held":false},{"id":"LN1652784535207","name":"Hadhayosh-34","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":520,"y":180},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"startArrowStyle":"NONE","endArrowStyle":"UNFILLED","startArrowSize":"SMALL","endArrowSize":"SMALL","secondaryCords":[{"x":548,"y":180}],"tempStartCord":null,"tempCord":null,"cordsSet":true,"held":false},{"id":"LN1652784649410","name":"Bashee-37","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":764,"y":320},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"startArrowStyle":"NONE","endArrowStyle":"ARROW","startArrowSize":"SMALL","endArrowSize":"SMALL","secondaryCords":[{"x":848,"y":320},{"x":840,"y":212},{"x":884,"y":192},{"x":924,"y":200},{"x":908,"y":416}],"tempStartCord":null,"tempCord":null,"cordsSet":true,"held":false},{"id":"LN1652890388952","name":"Fomorians-4","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":0,"y":0},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"startArrowStyle":"NONE","endArrowStyle":"NONE","startArrowSize":"SMALL","endArrowSize":"SMALL","secondaryCords":[],"tempStartCord":null,"tempCord":null,"cordsSet":true,"held":false},{"id":"LN1652890502776","name":"Huay Chay-1","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":0,"y":0},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"startArrowStyle":"NONE","endArrowStyle":"NONE","startArrowSize":"SMALL","endArrowSize":"SMALL","secondaryCords":[],"tempStartCord":null,"tempCord":null,"cordsSet":true,"held":false},{"id":"SH1652895519813","name":"Cacus-2","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":312,"y":500},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":96,"sizeY":36},"shape":"RECT","link":"","text":"","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":true,"_chunks":[]},{"id":"LN1652980579178","name":"Yali-1","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":332,"y":300},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"startArrowStyle":"NONE","endArrowStyle":"ARROW","startArrowSize":"SMALL","endArrowSize":"SMALL","secondaryCords":[{"x":376,"y":444}],"tempStartCord":null,"tempCord":null,"cordsSet":true,"held":false},{"id":"LN1652980588809","name":"Redcap-2","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":196,"y":548},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"startArrowStyle":"NONE","endArrowStyle":"ARROW","startArrowSize":"SMALL","endArrowSize":"SMALL","secondaryCords":[{"x":332,"y":472}],"tempStartCord":null,"tempCord":null,"cordsSet":true,"held":false},{"id":"LN1652980633399","name":"Redcap-3","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":692,"y":316},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"startArrowStyle":"NONE","endArrowStyle":"ARROW","startArrowSize":"SMALL","endArrowSize":"SMALL","secondaryCords":[{"x":764,"y":320},{"x":764,"y":416}],"tempStartCord":null,"tempCord":null,"cordsSet":true,"held":false},{"id":"SH1652783215734","name":"Humbaba-21","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":128,"y":276},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":296,"sizeY":28},"shape":"RECT","link":"","text":"CapTransformationIndexingEventHandler","textSize":15,"textColor":"#000000","textAlign":"CENTER","fillColor":"#fefbea","isFilled":true,"_chunks":[{"x":142.4390243902439,"y":295,"text":"CapTransformationIndexingEventHandler"}]}],"isHoverable":true,"hoverBorderColor":"#77DD66","isSelectable":true,"isSelectedByDefault":false,"selectedFillColor":"#c1e1c5","selectedBorderColor":"#265828","_display":true},{"id":"EP1652895298037","name":"Bashee-0","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":96,"y":668},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":228,"sizeY":96},"shape":"ROUNDEDRECT","link":"","text":"","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#d4c4fb","isFilled":true,"_chunks":[],"elements":[{"id":"SH1652895301582","name":"Loch Ness Monster-1","color":"#5300eb","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":532,"y":600},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":244,"sizeY":136},"shape":"RECT","link":"","text":"","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fad0c3","isFilled":true,"_chunks":[]},{"id":"SEP1652895828150","name":"Bashee-0-Monocerus-0-aaa","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":828,"y":640},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":148,"sizeY":76},"shape":"ROUNDEDRECT","link":"","text":"","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":true,"_chunks":[],"elements":[{"id":"SEP1652895836718","name":"Bashee-0-Monocerus-0-aaa-Simargl-1","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":52,"y":336},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":168,"sizeY":116},"shape":"ROUNDEDRECT","link":"","text":"Something with lots more text that will actually display every where","textSize":15,"textColor":"#000000","textAlign":"CENTER","fillColor":"#696969","isFilled":true,"_chunks":[{"x":66.60869565217392,"y":376.5,"text":"Something with lots"},{"x":66.60869565217392,"y":391.5,"text":"more text that will"},{"x":55.65217391304347,"y":406.5,"text":"actually display every"},{"x":110.23913043478261,"y":421.5,"text":"where"}],"elements":[],"isHoverable":true,"hoverBorderColor":"#77DD66","isSelectable":true,"isSelectedByDefault":false,"selectedFillColor":"#008b02","selectedBorderColor":"#265828","_display":true}],"isHoverable":true,"hoverBorderColor":"#77DD66","isSelectable":true,"isSelectedByDefault":false,"selectedFillColor":"#eee","selectedBorderColor":"#265828","_display":true},{"id":"LN1652980524138","name":"Fomorians-0","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":324,"y":720},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"startArrowStyle":"NONE","endArrowStyle":"ARROW","startArrowSize":"SMALL","endArrowSize":"SMALL","secondaryCords":[{"x":468,"y":700},{"x":420,"y":552},{"x":456,"y":484}],"tempStartCord":null,"tempCord":null,"cordsSet":true,"held":false},{"id":"SEP1652982179409","name":"Bashee-0-Fenrir-0","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":516,"y":752},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":124,"sizeY":32},"shape":"ROUNDEDRECT","link":"","text":"","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":true,"_chunks":[],"elements":[{"id":"SEP1652982207425","name":"Bashee-0-Fenrir-0-Ushi-oni-1","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":716,"y":752},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":124,"sizeY":32},"shape":"ROUNDEDRECT","link":"","text":"","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":true,"_chunks":[],"elements":[{"id":"SH1652982210009","name":"Unktehila-2","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":868,"y":744},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":140,"sizeY":44},"shape":"RECT","link":"","text":"","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":true,"_chunks":[]}],"isHoverable":true,"hoverBorderColor":"#77DD66","isSelectable":true,"isSelectedByDefault":false,"selectedFillColor":"#eee","selectedBorderColor":"#265828","_display":true}],"isHoverable":true,"hoverBorderColor":"#77DD66","isSelectable":true,"isSelectedByDefault":false,"selectedFillColor":"#eee","selectedBorderColor":"#265828","_display":true}],"isHoverable":true,"hoverBorderColor":"#d4c4fb","isSelectable":true,"isSelectedByDefault":false,"selectedFillColor":"#fef3bd","selectedBorderColor":"#b80000","_display":true},{"id":"EP1653145231619","name":"Humbaba-0","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":96,"y":92},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":152,"sizeY":52},"shape":"ROUNDEDRECT","link":"","text":"Front","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":true,"_chunks":[{"x":146.4047619047619,"y":123,"text":"Front"}],"elements":[{"id":"SH1653145252515","name":"Bashee-3","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":300,"y":80},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":136,"sizeY":48},"shape":"RECT","link":"","text":"Front","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":true,"_chunks":[{"x":342.60526315789474,"y":109,"text":"Front"}]}],"isHoverable":true,"hoverBorderColor":"#77DD66","isSelectable":true,"isSelectedByDefault":false,"selectedFillColor":"#eee","selectedBorderColor":"#265828","_display":true},{"id":"EP1653145237763","name":"Minotaur-1","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":120,"y":92},"_isHovered":false,"_isSelected":true,"_hoverOverride":true,"size":{"sizeX":172,"sizeY":68},"shape":"ROUNDEDRECT","link":"","text":"Back","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":true,"_chunks":[{"x":183.54347826086956,"y":131,"text":"Back"}],"elements":[{"id":"SH1653145245125","name":"Teju Jagua-2","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":316,"y":88},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":120,"sizeY":44},"shape":"RECT","link":"","text":"Back","textSize":15,"textColor":"#000","textAlign":"CENTER","fillColor":"#fff","isFilled":true,"_chunks":[{"x":354.38235294117646,"y":115,"text":"Back"}]},{"id":"SH1653146833428","name":"Dragon-4","color":"#000","strokeWidth":0.6,"lineStyle":"FULL","cords":{"x":752,"y":32},"_isHovered":false,"_isSelected":false,"_hoverOverride":false,"size":{"sizeX":140,"sizeY":100},"shape":"DATABASE","link":"","text":"SOLR","textSize":15,"textColor":"#000000","textAlign":"TOPCENTER","fillColor":"#bed3f3","isFilled":true,"_chunks":[{"x":799.7631578947369,"y":46,"text":"SOLR"}]}],"isHoverable":true,"hoverBorderColor":"#77DD66","isSelectable":true,"isSelectedByDefault":false,"selectedFillColor":"#eee","selectedBorderColor":"#265828","_display":true}],"_selecting":true,"_placing":false,"_defaultValues":{"width":1024,"height":800,"scale":4,"color":"#000","strokeWidth":0.6,"textColor":"#000","textSize":15,"fillColor":"#fff","hoverBorderColor":"#77DD66","selectedFillColor":"#eee","selectedBorderColor":"#265828","backgroundColor":"#F8F8F8"},"src":null,"version":"1.0.0"}
    // 

    load();

</script>










